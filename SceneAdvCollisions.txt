/*class Scene{
    gameObjects = []

    currentCollision = new Set()
    previousCollision = new Set()

    start(){
        for (const gameObject of this.gameObjects){
            gameObject.start()
            gameObject.hasStarted = true;
        }
    }

    update(){
        for(const gameObject of this.gameObjects){
            if(!gameObject.hasStarted){
                gameObject.start()
                gameObject.hasStarted = true
            }
            gameObject.update()
        }

        this.currentCollision.clear()


        const gameObjectsWithColliders = this.gameObjects.filter(go => go.getComponent(Collider))

        for(let i = 0; i < gameObjectsWithColliders.length; i++){
            for(let j = i+1; j < gameObjectsWithColliders.length; j++){
                let a = gameObjectsWithColliders[i]
                let b = gameObjectsWithColliders[j]

                let response = Collisions.inCollision(a, b)
                const key = `${a.id},${b.id}`

                if(response){
                    this.currentCollision.add(key)

                    const aHasRigidBody = a.getComponent(RigidBody)
                    const bHasRigidBody = b.getComponent(RigidBody)

                    if(aHasRigidBody){
                        if(a.transform.position.minus(b.transform.position).dot(response) < 0){
                            response = response.times(-1)
                        }
                        a.transform.position.plusEquals(response)
                    }
                    if(bHasRigidBody){
                        if(b.transform.position.minus(a.transform.position).dot(response) < 0){
                            response = response.times(-1)
                        }
                        b.transform.position.plusEquals(response)
                    }
                    
                    if(!this.previousCollision.has(key)){
                        for(const component of a.components){
                            component.onCollisionEnter?.(b)
                        }

                        for(const component of b.components){
                            component.onCollisionEnter?.(a)
                        }
                    }

                    if(this.previousCollision.has(key)){
                        for(const component of a.components){
                            component.onCollisionStay?.(b)
                        }

                        for(const component of b.components){
                            component.onCollisionStay?.(a)
                        }
                    }


                }
            }
        }

        for (let pair of this.previousCollision){
            if(!this.currentCollision.has(pair)){
                const [aID, bID] = pair.split(",")
                const a = this.gameObjects.find(go => go.id == aID)
                const b = this.gameObjects.find(go => go.id == bID)

                if (a && b){
                     for(const component of a.components){
                        component.onCollisionExit?.(b)
                    }

                    for(const component of b.components){
                        component.onCollisionExit?.(a)
                    }
                }

            }
        }

        this.previousCollision = new Set(this.currentCollision)

        this.gameObjects = this.gameObjects.filter(gameObject => !gameObject.markForDelete)
    }

    draw(ctx){
        for(const gameObject of this.gameObjects){
            gameObject.draw(ctx)
        }
    }

    instantiate(gameObject, position){
        this.gameObjects.push(gameObject)
        if (position){
            gameObject.transform.position = position
        }

        return gameObject
    }
}*/

/**
 * Base class for all scenes
 * 
 */